// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  PATIENT
  DOCTOR
  ADMIN
}

enum AppointmentStatus {
  PENDING_PAYMENT
  PENDING_VERIFICATION
  CONFIRMED
  COMPLETED
  CANCELLED
}

enum PaymentStatus {
  INITIATED
  PENDING_VERIFICATION
  PAID
  REJECTED
}

enum PaymentMethod {
  BKASH
  ROCKET
  NAGAD
  BANK_TRANSFER
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  password      String?
  role          Role      @default(PATIENT)
  phone         String?   @unique
  
  // Patient specific
  appointments Appointment[] @relation("PatientAppointments")
  
  // Doctor/Admin specific (design supports multiple doctors later)
  doctorProfile DoctorProfile?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model DoctorProfile {
  id          String   @id @default(cuid())
  userId      String   @unique
  user        User     @relation(fields: [userId], references: [id])
  specialties String[]
  bio         String?
  location    String?
  fees        Float
  
  availabilityRules AvailabilityRule[]
  exceptions        AvailabilityException[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Service {
  id          String   @id @default(cuid())
  name        String   // e.g., "Online Consultation", "Chamber Visit"
  description String?
  duration    Int      // in minutes
  fee         Float
  isActive    Boolean  @default(true)
  
  appointments Appointment[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model AvailabilityRule {
  id              String        @id @default(cuid())
  doctorProfileId String
  doctorProfile   DoctorProfile @relation(fields: [doctorProfileId], references: [id])
  dayOfWeek       Int           // 0-6 (Sunday to Saturday)
  startTime       String        // "HH:mm" (24-hour format)
  endTime         String        // "HH:mm"
  slotDuration    Int           @default(20) // overrides service duration if needed, or matches
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model AvailabilityException {
  id              String        @id @default(cuid())
  doctorProfileId String
  doctorProfile   DoctorProfile @relation(fields: [doctorProfileId], references: [id])
  date            DateTime      // Specific date blocked or with different hours
  isAvailable     Boolean       @default(false) // If false, doctor is off this day
  startTime       String?       // Optional: specific hours for this date
  endTime         String?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Appointment {
  id           String            @id @default(cuid())
  patientId    String
  patient      User              @relation("PatientAppointments", fields: [patientId], references: [id])
  serviceId    String
  service      Service           @relation(fields: [serviceId], references: [id])
  date         DateTime          // Only the date part
  startTime    String            // "HH:mm"
  endTime      String            // "HH:mm"
  status       AppointmentStatus @default(PENDING_PAYMENT)
  problem      String?           @db.Text
  meetingLink  String?
  
  payment      Payment?
  auditLogs    AuditLog[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([date, startTime, status]) // Basic double-booking prevention for CONFIRMED/PENDING
}

model Payment {
  id             String        @id @default(cuid())
  appointmentId  String        @unique
  appointment    Appointment   @relation(fields: [appointmentId], references: [id])
  amount         Float
  currency       String        @default("BDT")
  method         PaymentMethod
  status         PaymentStatus @default(INITIATED)
  
  // Last successful or current pending details
  transactionId  String?       @unique
  senderNumber   String?
  notes          String?
  screenshotUrl  String?
  
  attempts       PaymentAttempt[]
  
  verifiedAt     DateTime?
  verifiedBy     String?       // User ID of the doctor who verified
  
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

model PaymentAttempt {
  id            String        @id @default(cuid())
  paymentId     String
  payment       Payment       @relation(fields: [paymentId], references: [id])
  method        PaymentMethod
  transactionId String
  senderNumber  String?
  notes         String?
  status        PaymentStatus
  
  createdAt     DateTime @default(now())
}

model NotificationLog {
  id        String   @id @default(cuid())
  recipient String   // email or phone
  type      String   // "EMAIL", "SMS", "WHATSAPP"
  event     String   // "BOOKING_CONFIRMED", "PAYMENT_FAILED", etc.
  status    String   // "SENT", "FAILED"
  payload   Json?
  
  createdAt DateTime @default(now())
}

model AuditLog {
  id            String      @id @default(cuid())
  appointmentId String?
  appointment   Appointment? @relation(fields: [appointmentId], references: [id])
  userId        String?
  action        String      // "STATUS_CHANGE", "PAYMENT_RECEIVED", etc.
  details       Json?
  
  createdAt DateTime @default(now())
}
